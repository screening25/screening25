export const javaConcepts = [
  // Chapter 2: 변수
  {
    id: "concept-2-1-1",
    chapter: "Chapter 2: 변수",
    title: "1.1 변수란?",
    content: "변수(Variable)는 단 하나의 값을 저장할 수 있는 메모리 공간을 의미함. 컴퓨터 메모리(RAM)는 1바이트 단위로 주소가 지정되어 있으나, 프로그래머가 직접 주소를 다루는 것은 매우 위험하고 비효율적이므로 변수라는 이름을 통해 메모리 특정 공간에 접근함. 변수에 새로운 값을 저장하면 기존의 값은 지워지고 마지막에 저장된 값만 남음."
  },
  {
    id: "concept-2-2-1",
    chapter: "Chapter 2: 변수",
    title: "2.1 변수의 타입",
    content: "자료형(Data Type)은 값의 종류에 따라 저장될 공간의 크기와 형식을 정의한 것임. 크게 기본형(Primitive Type)과 참조형(Reference Type)으로 나뉨. 기본형은 실제 값(data)을 저장하며 논리형, 문자형, 정수형, 실수형 등 8개가 존재함. 참조형은 객체의 주소(memory address)를 저장하며, 기본형을 제외한 나머지 타입(String, System 등)이 이에 해당함. 자바는 C언어와 달리 참조형 변수 간의 연산을 허용하지 않음."
  },
  // Chapter 3: 연산자
  {
    id: "concept-3-1-1",
    chapter: "Chapter 3: 연산자",
    title: "1.1 연산자와 피연산자",
    content: "연산자(Operator)는 연산을 수행하는 기호를 말하며, 피연산자(Operand)는 연산의 대상이 되는 변수나 상수를 의미함. 모든 연산자는 연산 결과를 반환함. 식(Expression)은 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것이며, 이 식을 계산하여 결과를 얻는 것을 평가(Evaluation)라고 함."
  },
  // Chapter 4: 조건문과 반복문
  {
    id: "concept-4-1-5",
    chapter: "Chapter 4: 조건문과 반복문",
    title: "1.5 switch문",
    content: "switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있는 조건문임. 조건식의 결과값과 일치하는 case문으로 이동하여 문장을 수행하며, break문을 만나면 전체 switch문을 빠져나감. 만약 break문이 없으면 다음 case문의 문장들도 계속 수행하는 'fall-through' 현상이 발생함. JDK 7부터는 조건식에 문자열(String)도 사용할 수 있게 되어 활용도가 높아짐."
  },
  {
    id: "concept-4-2-3",
    chapter: "Chapter 4: 조건문과 반복문",
    title: "2.3 while문",
    content: "while문은 조건식이 참(true)인 동안 블록 내의 문장을 반복해서 실행함. for문과 달리 초기화나 증감식이 필수가 아니며, 반복 횟수가 정해져 있지 않을 때 주로 사용함. 조건식이 처음부터 거짓이면 블록 내의 문장이 한 번도 실행되지 않을 수 있음. 무한 반복을 구현할 때는 조건식에 true를 넣음."
  },
  // Chapter 5: 배열
  {
    id: "concept-5-1-1",
    chapter: "Chapter 5: 배열",
    title: "1.1 배열이란?",
    content: "배열(Array)은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 자료구조임. 변수가 하나의 데이터만 저장할 수 있는 것과 달리, 배열은 많은 양의 데이터를 손쉽게 다룰 수 있음. 배열의 각 요소는 연속된 메모리 공간에 저장되며, 인덱스(index)를 통해 각 요소에 접근함. 자바에서 배열은 객체로 취급되며, 배열의 길이는 생성 시 결정되어 변경할 수 없음."
  },
  // Chapter 6: 객체지향 프로그래밍 I
  {
    id: "concept-6-1-1",
    chapter: "Chapter 6: 객체지향 I",
    title: "1.1 클래스와 객체",
    content: "클래스(Class)는 객체를 정의해 놓은 설계도 또는 틀이며, 객체(Object)는 클래스에 정의된 대로 메모리에 생성된 실체를 의미함. 클래스로부터 객체를 만드는 과정을 인스턴스화(Instantiation)라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(Instance)라고 함. 객체는 속성(변수)과 기능(메서드)으로 구성됨."
  },
  {
    id: "concept-6-3-1",
    chapter: "Chapter 6: 객체지향 I",
    title: "3.1 JVM 메모리 구조",
    content: "JVM의 메모리 구조는 크게 메서드 영역(Method Area), 호출 스택(Call Stack), 힙(Heap)으로 구분됨. 메서드 영역에는 클래스 정보(클래스 데이터, 클래스 변수)가 저장됨. 호출 스택은 메서드 작업 중 필요한 메모리 공간을 제공하며, 지역변수와 연산 결과가 저장되고 메서드 종료 시 자동 제거됨. 힙 영역은 인스턴스가 생성되는 공간으로, 프로그램 실행 중 생성되는 모든 인스턴스는 이곳에 저장되며 GC(Garbage Collector)에 의해 관리됨."
  },
  // Chapter 7: 객체지향 프로그래밍 II
  {
    id: "concept-7-3-1",
    chapter: "Chapter 7: 객체지향 II",
    title: "3.1 다형성(Polymorphism)",
    content: "다형성은 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 구현함. 구체적으로는 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있음. 이를 통해 유연한 코드를 작성할 수 있으며, 매개변수의 다형성이나 여러 종류의 객체를 하나의 배열로 다루는 이종 컬렉션 등이 가능해짐."
  },
  {
    id: "concept-7-5-1",
    chapter: "Chapter 7: 객체지향 II",
    title: "5.1 인터페이스(Interface)",
    content: "인터페이스는 일종의 추상 클래스이지만, 추상 클래스보다 추상화 정도가 높아 일반 메서드나 멤버 변수를 가질 수 없음(JDK 1.8 이전 기준). 오직 추상 메서드와 상수만을 멤버로 가질 수 있으며, 다른 클래스를 작성하는 데 도움을 줄 목적으로 작성됨. 인터페이스를 통해 표준화된 개발이 가능하며, 서로 관계없는 클래스들에게 관계를 맺어주거나 다중 상속과 유사한 효과를 낼 수 있음."
  },
  // Chapter 8: 예외처리
  {
    id: "concept-8-1-1",
    chapter: "Chapter 8: 예외처리",
    title: "1.1 예외처리와 try-catch",
    content: "프로그램 실행 중 발생할 수 있는 오류는 에러(Error)와 예외(Exception)로 나뉨. 에러는 메모리 부족이나 스택오버플로우 같이 복구할 수 없는 심각한 오류이고, 예외는 수습될 수 있는 비교적 덜 심각한 오류임. 예외처리는 예외 발생 시 프로그램의 비정상 종료를 막고 정상적인 실행 상태를 유지하기 위해 try-catch문을 사용함. try 블록 내에서 예외가 발생하면, 일치하는 catch 블록을 찾아 처리함."
  },
  // Chapter 9: java.lang 패키지
  {
    id: "concept-9-1-1",
    chapter: "Chapter 9: java.lang",
    title: "1.1 Object 클래스",
    content: "Object 클래스는 모든 클래스의 최고 조상으로, 자바의 모든 클래스는 자동적으로 Object 클래스를 상속받음. 따라서 모든 클래스는 Object 클래스에 정의된 멤버들을 사용할 수 있음. 주요 메서드로는 객체의 주소를 비교하는 equals(), 객체의 해시코드를 반환하는 hashCode(), 객체의 문자열 정보를 반환하는 toString() 등이 있으며, 이를 오버라이딩하여 클래스에 맞게 재정의하여 사용하는 것이 일반적임."
  },
  {
    id: "concept-9-2-1",
    chapter: "Chapter 9: java.lang",
    title: "2.1 String 클래스의 불변성",
    content: "String 클래스는 문자열을 저장하기 위해 문자형 배열(char[])을 내부 변수로 가짐(JDK 9부터는 byte[]). String 인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고 변경할 수는 없는 불변(immutable) 객체임. '+' 연산자 등으로 문자열을 결합하면 기존 객체가 변경되는 것이 아니라 새로운 문자열 객체가 생성됨. 따라서 문자열 변경이 잦은 경우 StringBuffer나 StringBuilder를 사용하는 것이 메모리 효율적임."
  },
  // Chapter 10: 날짜와 시간
  {
    id: "concept-10-2-1",
    chapter: "Chapter 10: 날짜와 시간",
    title: "2.1 java.time 패키지",
    content: "JDK 1.8부터 추가된 java.time 패키지는 기존 Calendar와 Date 클래스의 단점(mutable, 불명확한 월 인덱스 등)을 개선한 새로운 날짜/시간 API임. 핵심 클래스인 LocalDate, LocalTime, LocalDateTime 등은 모두 불변(immutable) 객체로 설계되어 멀티쓰레드 환경에서 안전함. 또한 날짜와 시간을 변경하는 메서드들은 항상 새로운 객체를 반환하며, 메서드 체이닝을 지원하여 가독성이 좋음."
  },
  // Chapter 11: 컬렉션 프레임웍
  {
    id: "concept-11-1-1",
    chapter: "Chapter 11: 컬렉션",
    title: "1.1 ArrayList",
    content: "ArrayList는 컬렉션 프레임웍에서 가장 많이 사용되는 클래스 중 하나로, List 인터페이스를 구현함. 데이터의 저장 순서가 유지되고 중복을 허용함. 내부적으로 Object 배열을 이용하여 데이터를 순차적으로 저장하며, 배열의 크기가 부족하면 더 큰 배열을 생성하고 기존 데이터를 복사하는 과정이 자동으로 수행됨. 데이터의 순차적 추가/삭제는 빠르지만, 중간에 데이터를 추가/삭제하는 경우 데이터 이동이 발생하여 비효율적일 수 있음."
  },
  {
    id: "concept-11-1-6",
    chapter: "Chapter 11: 컬렉션",
    title: "1.6 HashMap",
    content: "HashMap은 Map 인터페이스를 구현한 대표적인 클래스로, 키(Key)와 값(Value)을 하나의 쌍으로 묶어서 저장함. 해싱(Hashing) 기법을 사용하여 데이터를 저장하고 검색하기 때문에 대량의 데이터 중에서도 특정 데이터를 검색하는 속도가 매우 빠름. 키는 중복을 허용하지 않으나 값은 중복을 허용함. 내부적으로 배열과 링크드 리스트가 조합된 형태(버킷)로 데이터를 저장함."
  },
  // Chapter 12: 지네릭스, 열거형, 애너테이션
  {
    id: "concept-12-1-1",
    chapter: "Chapter 12: 지네릭스 등",
    title: "1.1 지네릭스(Generics)",
    content: "지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능임. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌. 'ArrayList<String>'과 같이 선언하면 해당 리스트에는 String 타입의 객체만 저장할 수 있음을 컴파일러가 보장함."
  },
  {
    id: "concept-12-3-1",
    chapter: "Chapter 12: 지네릭스 등",
    title: "3.1 애너테이션(Annotation)",
    content: "애너테이션은 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것임. 주석(Comment)처럼 프로그래밍 언어에 영향을 미치지 않으면서도 유용한 정보를 제공함. 예를 들어 '@Override'는 컴파일러에게 해당 메서드가 오버라이딩된 것임을 알리고 체크하게 함. 자바의 리플렉션 API를 통해 런타임에 애너테이션 정보를 읽어 처리할 수 있어 프레임워크 등에서 널리 사용됨."
  },
  // Chapter 13: 쓰레드
  {
    id: "concept-13-1-1",
    chapter: "Chapter 13: 쓰레드",
    title: "1.1 프로세스와 쓰레드",
    content: "프로세스(Process)는 실행 중인 프로그램으로, 자원(메모리, CPU 등)과 쓰레드로 구성됨. 쓰레드(Thread)는 프로세스 내에서 실제 작업을 수행하는 단위이며, 모든 프로세스는 최소한 하나의 쓰레드를 가짐. 멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 자원을 공유하며 동시에 작업을 수행하는 것을 말함. 이를 통해 CPU 사용률을 향상시키고 자원을 효율적으로 사용할 수 있으나, 동기화(Synchronization)나 교착상태(Deadlock) 같은 문제에 주의해야 함."
  },
  {
    id: "concept-13-5-1",
    chapter: "Chapter 13: 쓰레드",
    title: "5.1 동기화(Synchronization)",
    content: "멀티쓰레드 환경에서는 여러 쓰레드가 같은 프로세스 내의 자원을 공유하기 때문에, 서로의 작업에 영향을 주게 됨. 이를 방지하기 위해 한 쓰레드가 특정 작업을 마치기 전까지 다른 쓰레드가 방해하지 못하도록 하는 것이 동기화임. 자바에서는 synchronized 키워드를 통해 임계 영역(Critical Section)을 설정하여 락(Lock)을 획득한 단 하나의 쓰레드만 코드를 실행할 수 있도록 보장함."
  },
  // Chapter 14: 람다와 스트림
  {
    id: "concept-14-1-1",
    chapter: "Chapter 14: 람다/스트림",
    title: "1.1 람다식(Lambda Expression)",
    content: "람다식은 메서드를 하나의 '식(Expression)'으로 표현한 것으로, 함수를 간결하고 명확하게 표현할 수 있게 해줌. 메서드의 이름과 반환타입을 생략하고 '->'를 사용하여 작성하므로 익명 함수(Anonymous Function)라고도 함. 자바에서는 람다식을 익명 객체로 취급하며, 함수형 인터페이스(Functional Interface)를 통해 람다식을 다룸. 이를 통해 자바에서도 함수형 프로그래밍의 요소를 활용할 수 있게 됨."
  },
  {
    id: "concept-14-2-1",
    chapter: "Chapter 14: 람다/스트림",
    title: "2.1 스트림(Stream)",
    content: "스트림은 데이터 소스(컬렉션, 배열 등)를 추상화하고, 데이터를 다루는 데 자주 사용되는 메서드들을 정의해 놓은 것임. 스트림을 사용하면 데이터 소스가 무엇이든 간에 같은 방식으로 다룰 수 있어 코드의 재사용성이 높아짐. 스트림 연산은 중간 연산과 최종 연산으로 분류되며, 중간 연산은 연산 결과를 스트림으로 반환하여 연속해서 연결할 수 있고(파이프라인), 최종 연산은 스트림의 요소를 소모하여 결과를 반환함. 또한 지연 연산(Lazy Evaluation)을 통해 효율적인 처리가 가능함."
  },
  // Chapter 15: 입출력
  {
    id: "concept-15-1-1",
    chapter: "Chapter 15: 입출력",
    title: "1.1 입출력(I/O)과 스트림",
    content: "입출력(I/O)은 컴퓨터 내부 또는 외부의 장치와 프로그램 간에 데이터를 주고받는 것을 말함. 자바에서는 입출력을 수행하기 위해 스트림(Stream)이라는 개념을 사용함. 스트림은 데이터를 운반하는 단방향 통로로, 입력 스트림과 출력 스트림이 별도로 존재함. 스트림은 먼저 보낸 데이터를 먼저 받게 되는 FIFO(First In First Out) 구조로 되어 있으며, 바이트 기반 스트림과 문자 기반 스트림으로 나뉨."
  },
  {
    id: "concept-15-7-1",
    chapter: "Chapter 15: 입출력",
    title: "7.1 직렬화(Serialization)",
    content: "직렬화는 객체를 데이터 스트림으로 만드는 것을 뜻하며, 객체에 저장된 데이터를 스트림에 쓰기(write) 위해 연속적인 데이터로 변환하는 것임. 반대로 스트림으로부터 데이터를 읽어서 객체를 만드는 것을 역직렬화(Deserialization)라고 함. 객체를 파일에 저장하거나 네트워크를 통해 전송하기 위해서는 반드시 직렬화 과정이 필요함. 자바에서는 Serializable 인터페이스를 구현한 클래스의 객체만 직렬화할 수 있음."
  },
  // Chapter 16: 네트워킹
  {
    id: "concept-16-1-1",
    chapter: "Chapter 16: 네트워킹",
    title: "1.1 클라이언트/서버",
    content: "네트워킹은 두 대 이상의 컴퓨터를 케이블 등으로 연결하여 네트워크를 구성하는 것을 말함. 클라이언트/서버 모델은 서비스를 제공하는 쪽(Server)과 서비스를 사용하는 쪽(Client)으로 역할을 구분한 것임. 서버는 클라이언트의 요청(Request)을 기다리고 있다가 요청이 오면 그에 맞는 서비스(Response)를 제공함. 자바는 java.net 패키지를 통해 소켓 프로그래밍을 지원하며 TCP/IP 및 UDP 프로토콜을 쉽게 사용할 수 있음."
  },
  {
    id: "concept-16-2-1",
    chapter: "Chapter 16: 네트워킹",
    title: "2.1 TCP 소켓 프로그래밍",
    content: "TCP/IP 프로토콜은 연결지향적이며 신뢰성 있는 데이터 전송을 보장함. 자바에서는 ServerSocket과 Socket 클래스를 사용하여 TCP 소켓 프로그래밍을 구현함. ServerSocket은 포트를 열고 클라이언트의 연결 요청을 기다리다가, 요청이 오면 새로운 Socket을 생성하여 클라이언트와 통신할 수 있게 함. Socket은 두 호스트 간의 연결을 나타내며, InputStream과 OutputStream을 통해 데이터를 주고받음. 1:1 통신이 기본이며, 채팅 서버와 같이 다대다 통신을 위해서는 멀티쓰레드를 활용해야 함."
  }
];
