export const chapter11Concepts = [
  {
    id: "concept-11-1-1",
    chapter: "Chapter 11: 컬렉션",
    title: "### 1.1 ArrayList",
    content: "ArrayList는 List 인터페이스를 구현한 대표적인 컬렉션 클래스로, 내부적으로 Object 배열을 사용하여 데이터를 관리한다. 데이터의 저장 순서가 유지되고 중복을 허용한다. 배열 기반이므로 인덱스를 이용한 임의 접근(random access) 속도가 매우 빠르다(O(1)). 하지만 데이터 추가/삭제 시, 특히 중간에 있는 데이터를 삭제할 경우, 뒤따르는 모든 요소들을 한 칸씩 앞으로 이동시켜야 하므로 성능 저하가 발생할 수 있다(O(n))."
  },
  {
    id: "concept-11-1-2",
    chapter: "Chapter 11: 컬렉션",
    title: "### 1.2 LinkedList",
    content: "LinkedList는 각 노드(Node)가 데이터와 다음 노드의 주소를 가지며, 이 노드들이 연결된 형태로 데이터를 저장하는 자료구조이다. 데이터의 추가/삭제 시, 해당 노드의 앞뒤 연결만 변경하면 되므로 매우 빠르다(O(1)). 하지만 특정 위치의 데이터에 접근하려면 처음부터 순차적으로 노드를 따라가야 하므로 검색 속도가 느리다(O(n)). 따라서 데이터의 추가/삭제가 빈번한 경우에 사용하는 것이 유리하다."
  },
  {
    id: "concept-11-1-3",
    chapter: "Chapter 11: 컬렉션",
    title: "### 1.3 Stack과 Queue",
    content: "Stack은 마지막에 저장한 데이터를 가장 먼저 꺼내는 LIFO(Last-In-First-Out, 후입선출) 구조의 자료구조이다. 자바에서는 Stack 클래스로 구현되어 있으며, push()로 데이터를 추가하고 pop()으로 데이터를 꺼낸다. Queue는 처음에 저장한 데이터를 가장 먼저 꺼내는 FIFO(First-In-First-Out, 선입선출) 구조이다. 자바에서는 Queue가 인터페이스로 정의되어 있으며, 주로 LinkedList를 구현체로 사용한다. offer()로 데이터를 추가하고 poll()로 데이터를 꺼낸다."
  },
  {
    id: "concept-11-1-5",
    chapter: "Chapter 11: 컬렉션",
    title: "### 1.5 HashSet",
    content: "HashSet은 Set 인터페이스를 구현한 클래스로, 데이터의 중복을 허용하지 않고 저장 순서를 보장하지 않는 특징을 가진다. 내부적으로 HashMap을 사용하여 데이터를 저장하며, 객체를 저장하기 전에 해당 객체의 hashCode() 메서드를 호출하여 해시 코드를 얻고, 이 해시 코드를 기반으로 저장 위치를 결정한다. 같은 해시 코드를 가진 객체가 이미 존재하면 equals() 메서드로 다시 비교하여 중복 여부를 최종 판단한다. 따라서 중복을 올바르게 제거하려면 hashCode()와 equals() 메서드를 모두 적절히 오버라이딩해야 한다."
  },
  {
    id: "concept-11-1-6",
    chapter: "Chapter 11: 컬렉션",
    title: "### 1.6 HashMap",
    content: "HashMap은 키(Key)와 값(Value)을 하나의 쌍으로 묶어 저장하는 Map 인터페이스의 대표적인 구현체이다. 해싱(Hashing) 원리를 사용하여 데이터를 저장하므로, 데이터의 양에 관계없이 추가, 삭제, 검색 속도가 평균적으로 O(1)에 가까워 매우 빠르다. 키는 중복될 수 없으며, 만약 동일한 키로 값을 다시 저장하면 기존 값은 새로운 값으로 덮어쓰여진다. 값은 중복을 허용한다. 키와 값 모두 null을 허용한다. 저장 순서는 보장되지 않는다."
  }
];